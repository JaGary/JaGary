函数：

> 声明：
>

``

声明式

function  函数名( ) {

​	//代码块

}

``

> 赋值式

``

var 函数名 = function( ){

​	//代码块

}

``

> 调用：

​	普通调用：

​		函数名( )

​	事件驱动调用：

​		 btn.onclick = 函数名；

​		 btn.onclick = function() {

​			//代码块

​			}

> *参数

​	形参

​	实参

> *返回值

  	*return

​		*可以把数据返回给入口(调用函数的地方)

​		*return后的语句不再被执行

​		*



> 声明式和赋值式的区别:

*声明式：入口可以写在任意地方

*赋值式：入口只能写在声明体下面：先声明，后调用  否则就会出现 sum is not a function;



> 声明提前（面试题）：变量或函数的提升

​		*系统会自动帮你把函数和变量声明提前

> ? 可能会遇到的问题：

​	undefined 声明未赋值；sum is not defined该变量还没有声明 



> 作用域;

​	*全局作用域：函数外面就是全局作用域

​	*局部作用域：函数里面就是局部作用域



> 变量： 外面的拿不到里面的变量，里面的可以拿到外面的变量

​	*全局变量：在全局作用域下面声明的变量，声明在函数外部的变量

​	*局部变量：在局部作用域下面声明的变量，声明在函数体的变量

> 例如：

var num = 88;//全局变量

​    function show() {

​        var price = 99;//局部变量

​        console.log('局部变量:' + price);//可以

​        console.log('局部获取全局：' + num);//可以

​    }

show();

console.log(num);//全局作用域可以拿到全局的变量,全局下面拿不到局部的变量



作用域链：从内到外，从下往上找，就近原则，找不到就找父函数，一直往外找，直到找到全局作用域为止，还是找不到的话，返回sum is not defined;你的就是我的,我的还是我的 



> 变量尽量的写成局部变量

​            \* 局部变量用完会被回收销毁，垃圾回收机制会自动销毁局部变量，全局变量不会被回收，浪												     费内存

​            \* 局部变量只在局部作用域范围内起作用，不担心同名覆盖问题

> 自调用：

自己调用自己，写匿名函数;有时候页面会出现空白，原因很多,把js放在底部加载，可以让body的节点优先加载，用户马上看到页面，体验较好，js特效延迟一点加载不影响整体效果 

 

